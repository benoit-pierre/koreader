#!/usr/bin/env bash

set -eo pipefail

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
    echo "incompatible bash version: ${BASH_VERSION}, need >=4.0"
    exit 1
fi

# shellcheck disable=2034
declare -r ANSI_BLUE=$'\e[34;1m'
# shellcheck disable=2034
declare -r ANSI_DIM=$'\e[2m'
declare -r ANSI_GREEN=$'\e[32;1m'
declare -r ANSI_RED=$'\e[31;1m'
declare -r ANSI_RESET=$'\e[0m'
declare -r E_OPTERR=85

opt_dry_run=0
opt_timings=0

function info() {
    local color=ANSI_BLUE
    if [[ "$1" = -c* ]]; then
        color="ANSI_${1#-c}"
        shift
    fi
    if [[ -t 2 ]]; then
        echo "${!color}$*${ANSI_RESET}" 1>&2
    else
        echo "$*" 1>&2
    fi
}

function err() {
    info -cRED "$@"
}

function die() {
    local code=$?
    if [[ $# -ne 0 ]]; then
        code="$1"
        shift
    fi
    if [[ $# -ne 0 ]]; then
        err "$@"
    fi
    exit "${code}"
}

function print_quoted() {
    if [[ $# -ne 0 ]]; then
        printf '%q' "$1"
        shift
    fi
    if [[ $# -ne 0 ]]; then
        printf ' %q' "$@"
    fi
}

function run() {
    info "$(print_quoted "$@")"
    if [[ ${opt_dry_run} -ne 0 ]]; then
        return
    fi
    local cmd=("$@")
    local code=0
    if [[ ${opt_timings} -ne 0 ]]; then
        time "${cmd[@]}" || code=$?
    else
        "${cmd[@]}" || code=$?
    fi
    return ${code}
}

function run_make() {
    local cmd=(make)
    if [[ ${opt_dry_run} -ne 0 ]]; then
        cmd+=(-n)
    fi
    if [[ "${CURDIR}" != "${PWD}" ]]; then
        cmd+=(-C "${CURDIR}")
    fi
    for param in TARGET KODEBUG VERBOSE; do
        cmd+=("${param}=${!param}")
    done
    cmd+=("$@")
    opt_dry_run=0 run "${cmd[@]}"
}

function setenv() {
    info "$(printf 'export %q\n' "$@")"
    # shellcheck disable=SC2163
    export "$@"
}

function addpath() {
    info "export PATH=$(print_quoted "$1"):\"\$PATH\""
    export PATH="$1:${PATH}"
}

function download() {
    run wget --continue --no-verbose --progress=dot:mega --show-progress "$@"
}

CURDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

function setup_target() {
    TARGET="$1"
    shift 1
    local valid=1
    case "${TARGET}" in
        # Emulator.
        '')
            if [[ "${CMD}" == 'release' ]]; then
                valid=0
            fi
            TARGET='emulator'
            ;;
        emulator*)
            if [[ "${CMD}" == 'release' ]]; then
                valid=0
            fi
            ;;
        appimage)
            if [[ "${CMD}" != 'release' ]]; then
                valid=0
            fi
            TARGET='emulator'
            ;;
        # Devices.
        android-*) ;;
        kindlepw2) ;;
        *)
            valid=0
            ;;
    esac
    if [[ "${valid}" -eq 0 ]]; then
        err "ERROR: unsupported ${CMD} target \"${TARGET}\"."
        echo "${HELP}"
        exit 1
    fi
    if [[ -z ${KODEBUG+x} && "${TARGET}" = emulator* && "${CMD}" != 'release' ]]; then
        # For the emulator, build a debug build by default.
        KODEBUG=1
    fi
}

function kodev-fetch-thirdparty() {
    run_make fetch-thirdparty
}

declare -r TARGETS_HELP_MSG="
TARGET:

    android-arm
    android-arm64
    android-x86
    android-x86_64
    kindlepw2       for Kindle models >= Paperwhite 2
    emulator        default if no TARGET is given"

declare -r RELEASE_TARGETS_HELP_MSG="${TARGETS_HELP_MSG/emu*/""}appimage"

declare -r BUILD_GETOPT_SHORT='bdnv'
declare -r BUILD_GETOPT_LONG='no-build,debug,no-debug,verbose'

function build_options_help_msg() {
    local section="$1"
    local no_build_details="$2"
    local debug_details="$3"
    local no_debug_details="$4"
    echo "
${section}${section:+ }OPTIONS:

    ${no_build_details:+-b, --no-build            do not build (}${no_build_details}${no_build_details:+)
    }-d, --debug               enable debugging symbols${debug_details:+ (}${debug_details}${debug_details:+)}
    -n, --no-debug            no debugging symbols${no_debug_details:+ (}${no_debug_details}${no_debug_details:+)}
    -v, --verbose             make the build system more verbose
"
}

function parse_options() {
    local short_opts="$1"
    local long_opts="$2"
    local args_spec="$3"
    shift 3
    # First things first: check if getopt is a compatible (util-linux like) version.
    if getopt -T >/dev/null 2>&1 || [[ $? -ne 4 ]]; then
        die 1 "unsupported getopt version: $(getopt --version)"
    fi
    if ! opt=$(getopt -o "h${short_opts}" --long "help,${long_opts}" --name "kodev" -- "$@"); then
        echo "${HELP}"
        exit ${E_OPTERR}
    fi
    # echo "opt: $opt"
    eval set -- "${opt}"
    OPTS=()
    ARGS=()
    while true; do
        case "$1" in
            -h | --help)
                echo "${HELP}"
                exit 0
                ;;
            -b | --no-build)
                NO_BUILD=1
                ;;
            -d | --debug)
                KODEBUG=1
                ;;
            -n | --no-debug)
                KODEBUG=
                ;;
            -v | --verbose)
                # shellcheck disable=SC2034
                VERBOSE=1
                ;;
            --)
                shift
                break
                ;;
            *)
                OPTS+=("$1")
                ;;
        esac
        shift
    done
    local expected
    local valid=0
    case "${args_spec}" in
        '*') ;;
        '+')
            expected='1 or more'
            [[ $# -ge 1 ]] || valid=1
            ;;
        '?')
            expected='1 optional'
            [[ $# -le 1 ]] || valid=1
            ;;
        *)
            expected="${args_spec}"
            [[ $# -eq "${args_spec}" ]] || valid=1
            ;;
    esac
    if [[ ${valid} -ne 0 ]]; then
        err "ERROR: invalid ${CMD} arguments; ${expected} expected but $# received"
        echo "${HELP}"
        exit 8
    fi
    ARGS=("$@")
    # echo "OPTS: ${OPTS[@]} [${#OPTS[@]}]"
    # echo "ARGS: ${ARGS[@]} [${#ARGS[@]}]"
}

function kodev-build() {
    CMD='build'
    HELP="
usage: build <OPTIONS> <TARGET>
$(build_options_help_msg '' 'stop after the setup phase' 'default for emulator' 'default for target devices')
${TARGETS_HELP_MSG}
"
    parse_options \
        "h${BUILD_GETOPT_SHORT}" \
        "help,${BUILD_GETOPT_LONG}" \
        '?' "$@"
    setup_target "${ARGS[0]}" 'build'
    run_make ${NO_BUILD:+setup}
}

function kodev-clean() {
    CMD='clean'
    HELP="
usage: clean <TARGET>
$(build_options_help_msg '' '' 'clean debug build' 'clean release build')
${TARGETS_HELP_MSG}
"
    parse_options \
        "h${BUILD_GETOPT_SHORT/b/}" \
        "help,${BUILD_GETOPT_LONG/no-build,/}" \
        '?' "$@"
    setup_target "${ARGS[0]}" 'clean'
    run_make clean
}

function kodev-release() {
    CMD='release'
    HELP="
usage: release <OPTIONS> <TARGET>

OPTIONS:

    -i, --ignore-translation  do not fetch translation for release

$(build_options_help_msg 'BUILD' 'create update from existing build' '' 'default')

${RELEASE_TARGETS_HELP_MSG}
"
    parse_options \
        "ih${BUILD_GETOPT_SHORT}" \
        "ignore-translation,help,${BUILD_GETOPT_LONG}" \
        '1' "$@"

    local ignore_translation=0
    for opt in "${OPTS[@]}"; do
        case "${opt}" in
            -i | --ignore-translation)
                ignore_translation=1
                ;;
        esac
    done

    local update='update'
    if [[ "${ARGS[0]}" == 'appimage' ]]; then
        update='appimageupdate'
    fi

    setup_target "${ARGS[0]}"

    if [ "${ignore_translation}" -eq 0 ]; then
        run_make po || {
            echo "ERROR: failed to fetch translation."
            echo "Tip: Use --ignore-translation OPTION if you want to build a release without translation."
            exit 1
        }
    fi

    run_make ${NO_BUILD:+--assume-old=all --assume-old=install} "${update}"
}

function kodev-wbuilder() {
    CMD='wbuilder'
    HELP="
usage: wbuilder
    "
    parse_options '' '' 0 "$@"
    setup_target 'emulator'
    echo "[*] Running wbuilder.lua..."
    run_make RPREFIX='EMULATE_READER_W=540 EMULATE_READER_H=720' run-wbuilder
}

function kodev-run() {
    VALGRIND=(valgrind --keep-debuginfo=yes --tool=memcheck --trace-children=yes --leak-check=full --track-origins=yes --show-reachable=yes)
    if [[ -r valgrind.sup ]]; then
        VALGRIND+=(--suppressions="${PWD}/valgrind.sup")
    fi
    CALLGRIND=(valgrind --tool=callgrind --trace-children=yes)
    # NOTE: Speaking of Valgrind, if your libdrm/mesa isn't built w/ valgrind markings, there's a Valgrind suppression file for AMD cards in the tools folder.
    #       Just append --suppressions=${PWD/tools/valgrind_amd.supp to your valgrind command.
    CMD='run'
    HELP="
usage: run <OPTIONS> <EMULATOR ARGS>
       run <OPTIONS> <ANDROID TARGET> [ANDROID APK]
$(build_options_help_msg '' 'use existing build' 'default for emulator' 'default for android target')

EMULATOR OPTIONS:

    -H X, --screen-height=X  set height of the emulator screen (default: 720)
    -W X, --screen-width=X   set width of the emulator screen (default: 540)
    -D X, --screen-dpi=X     set DPI of the emulator screen (default: 160)
    -t, --disable-touch      use this if you want to simulate keyboard only devices
    -s FOO --simulate=FOO    simulate dimension and other specs of the given device:
                             hidpi, kindle, kindle-paperwhite, kobo-aura-one, kobo-clara,
                             kobo-forma, kobo-h2o or legacy-paperwhite.
    -g X, --gdb=X            run with debugger (default: nemiver)
    -c, --callgrind          run with valgrind's callgrind (\`$(print_quoted "${CALLGRIND[@]}")\`)
    --valgrind=X             run with valgrind (default: \`$(print_quoted "${VALGRIND[@]}")\`)

    Extra arguments are forwarded to the emulator.

ANDROID TARGET:

    Install and run KOReader on an Android device connected through ADB.

    Supported targets: android-arm, android-arm64, android-x86 and android-x86_64.
"
    parse_options \
        "tg:::cW:H:D:s:${BUILD_GETOPT_SHORT}" \
        "disable-touch,gdb::,valgrind::,callgrind,screen-width:,screen-height:,screen-dpi:,simulate:,${BUILD_GETOPT_LONG}" \
        '*' "$@"

    # Defaults
    screen_width=540
    screen_height=720

    set -- "${OPTS[@]}"

    while [[ $# -gt 0 ]]; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#=/}"
        case "${PARAM}" in
            -t | --disable-touch)
                export DISABLE_TOUCH=1
                ;;
            -g | --gdb)
                if [ -n "${VALUE}" ]; then
                    read -r -a gdb <<<"${VALUE}"
                else
                    # Try to use friendly defaults for gdb
                    if command -v nemiver >/dev/null; then
                        # Nemiver is a nice GUI
                        gdb=(nemiver)
                    elif command -v ddd >/dev/null; then
                        # DDD is a slightly less nice GUI
                        gdb=(ddd)
                    elif command -v cgdb >/dev/null; then
                        # cgdb is a nice curses-based gdb front
                        gdb=(cgdb)
                    elif command -v gdb >/dev/null; then
                        # gdb -tui is a slightly less nice terminal user interface
                        gdb=(gdb -tui)
                    else
                        echo "Couldn't find gdb."
                        exit 1
                    fi
                fi
                shift
                ;;
            --valgrind)
                if [ -n "${VALUE}" ]; then
                    read -r -a valgrind <<<"${VALUE}"
                else
                    # Try to use sensible defaults for valgrind
                    if command -v valgrind >/dev/null; then
                        valgrind=("${VALGRIND[@]}")
                    else
                        echo "Couldn't find valgrind."
                        exit 1
                    fi
                fi
                shift
                ;;
            -c | --callgrind)
                # Try to use sensible defaults for valgrind
                if command -v valgrind >/dev/null; then
                    valgrind=("${CALLGRIND[@]}")
                else
                    echo "Couldn't find valgrind."
                    exit 1
                fi
                ;;
            -W | --screen-width)
                screen_width=${VALUE}
                shift
                ;;
            -H | --screen-height)
                screen_height=${VALUE}
                shift
                ;;
            -D | --screen-dpi)
                screen_dpi=${VALUE}
                shift
                ;;
            -s | --simulate)
                device_model="${VALUE}"
                case "${device_model}" in
                    kindle)
                        screen_width=600
                        screen_height=800
                        screen_dpi=167
                        ;;
                    legacy-paperwhite)
                        screen_width=758
                        screen_height=1024
                        screen_dpi=212
                        ;;
                    kobo-forma)
                        screen_width=1440
                        screen_height=1920
                        screen_dpi=300
                        ;;
                    kobo-aura-one)
                        screen_width=1404
                        screen_height=1872
                        screen_dpi=300
                        ;;
                    kobo-clara | kindle-paperwhite)
                        screen_width=1072
                        screen_height=1448
                        screen_dpi=300
                        ;;
                    kobo-h2o)
                        screen_width=1080
                        screen_height=1429
                        screen_dpi=265
                        ;;
                    hidpi)
                        screen_width=1500
                        screen_height=2000
                        screen_dpi=600
                        ;;
                    *)
                        echo "ERROR: spec unknown for ${device_model}."
                        ;;
                esac
                shift
                ;;
        esac
        shift
    done

    set -- "${ARGS[@]}"

    local target=''
    case "$1" in
        android*)
            target="$1"
            shift
            ;;
    esac

    setup_target "${target}" 'run' "${RUN_HELP_MSG}"

    local rprefix=()

    if [[ -z "${target}" ]]; then
        rprefix+=(EMULATE_READER_W="${screen_width}" EMULATE_READER_H="${screen_height}" EMULATE_READER_DPI="${screen_dpi}")
    fi

    if [[ "${#valgrind}" -gt 0 ]]; then
        rprefix+=("${valgrind[@]}")
    fi

    if [[ "${#gdb}" -gt 0 ]]; then
        # We don't want to stack valgrind on top of GDB ;).
        if [[ "${gdb[0]}" == gdb* ]]; then
            # The standard CLI needs a little hand holding to properly pass arguments to the process it'll monitor
            rprefix+=("${gdb[@]}" --args)
        else
            rprefix+=("${gdb[@]}")
        fi
    fi

    local margs=()

    if [[ "${target}" = android-* ]]; then
        if [[ "$1" = *.apk ]]; then
            margs+=(ANDROID_APK="$1")
            NO_BUILD=1
            shift
        fi
        if [[ ${#rprefix[@]} -gt 0 || $# -gt 0 ]]; then
            echo "${RUN_HELP_MSG}"
            exit ${E_OPTERR}
        fi
    fi

    local rargs=()

    for a in "$@"; do
        if [[ "${a}" != [-/]* ]]; then
            a="${PWD}/${a}"
        fi
        rargs+=("${a}")
    done

    if [[ ${#rprefix[@]} -gt 0 ]]; then
        margs+=(RPREFIX="$(print_quoted "${rprefix[@]}")")
    fi

    if [[ ${#rargs} -gt 0 ]]; then
        margs+=(RARGS="$(print_quoted "${rargs[@]}")")
    fi

    run_make "${margs[@]}" ${NO_BUILD:+--assume-old=all --assume-old=update} run
}

function kodev-test() {
    # shellcheck disable=SC1091
    source ./subprojects/koreader-runtests/runtests
    CMD='test'
    HELP="
usage: test <OPTIONS> <TEST_SUITE> <TEST_NAMES>

    TEST_SUITE: [all|base|front]. Optional: detault to all.

    TEST_NAMES: if no TEST_NAMES are given, the full testsuite is run.
${RUNTESTS_HELP}$(build_options_help_msg 'BUILD' 'use existing build' '' 'default')
"
    parse_options \
        "${RUNTESTS_GETOPT_SHORT},${BUILD_GETOPT_SHORT}" \
        "${RUNTESTS_GETOPT_LONG},${BUILD_GETOPT_LONG}" \
        '*' "$@"

    local targs=()
    # Optional argument options must be rewritten
    # so they are correctly forwarded to runtests:
    # `--opt val` -> `--opt=val`
    set -- "${OPTS[@]}"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --busted | --meson)
                targs+=("$1=$2")
                shift
                ;;
            *) targs+=("$1") ;;
        esac
        shift
    done
    targs+=("${ARGS[@]}")

    setup_target 'emulator'

    local margs=(runtests)
    if [[ ${#targs[@]} -gt 0 ]]; then
        margs+=(TARGS="$(print_quoted "${targs[@]}")")
    fi
    run_make ${NO_BUILD:+--assume-old=all} "${margs[@]}"
}

function kodev-check() {
    exit_code=0
    kodev-fetch-thirdparty

    # shellcheck disable=2016
    mapfile -t shellscript_locations < <({ git -c submodule.recurse=0 grep -lE '^#!(/usr)?/bin/(env )?(bash|sh)' | sed "/^plugins\/terminal.koplugin\/shfm$/d" && git submodule --quiet foreach '[ "$path" = "base" -o "$path" = "platform/android/luajit-launcher" ] || git grep -lE "^#!(/usr)?/bin/(env )?(bash|sh)" | sed "s|^|$path/|"' && git ls-files ./*.sh; } | sort | uniq)

    SHFMT_OPTIONS="-i 4 -ci"

    for shellscript in "${shellscript_locations[@]}"; do
        echo -e "${ANSI_GREEN}Running shellcheck on ${shellscript}"
        shellcheck "${shellscript}" || exit_code=1
        echo -e "${ANSI_GREEN}Running shfmt on ${shellscript}"
        # shellcheck disable=2086
        if ! shfmt ${SHFMT_OPTIONS} -kp "${shellscript}" >/dev/null 2>&1; then
            echo -e "${ANSI_RED}Warning: ${shellscript} contains the following problem:"
            # shellcheck disable=2086
            shfmt ${SHFMT_OPTIONS} -kp "${shellscript}" || exit_code=1
            continue
        fi
        # shellcheck disable=2086
        if [ "$(cat "${shellscript}")" != "$(shfmt ${SHFMT_OPTIONS} "${shellscript}")" ]; then
            echo -e "${ANSI_RED}Warning: ${shellscript} does not abide by coding style, diff for expected style:"
            # shellcheck disable=2086
            shfmt ${SHFMT_OPTIONS} -d "${shellscript}" || exit_code=1
        fi
    done

    echo -e "\\n${ANSI_GREEN}Checking for unscaled sizes"
    # stick `|| true` at the end to prevent exit on failed command
    unscaled_size_check=$(grep -nr --include=*.lua --exclude=koptoptions.lua --exclude-dir=base --exclude-dir=luajit-rocks --exclude-dir=install --exclude-dir=keyboardlayouts --exclude-dir=*arm* "\\(padding\\|margin\\|bordersize\\|width\\|height\\|radius\\|linesize\\) = [0-9]\\{1,2\\}" | grep -v '= 0' | grep -v '= [0-9]/[0-9]' | grep -Ev '(default_option_height|default_option_padding)' | grep -v scaleBySize | grep -v 'unscaled_size_check: ignore' || true)
    # Also check Geom objects; for legibility two regular expressions rather than
    # one enormous indecipharable blob.
    unscaled_size_check_geom=$(grep -E -nr --include=*.lua --exclude=gesturerange_spec.lua --exclude-dir=base --exclude-dir=luajit-rocks --exclude-dir=*arm* 'Geom:new{.+ [wh] = [0-9]{1,4}' | grep -Ev '[wh] = 0' | grep -v '= [0-9]/[0-9]' | grep -v scaleBySize || true)

    if [ "${unscaled_size_check}" ] || [ "${unscaled_size_check_geom}" ]; then
        echo -e "\\n${ANSI_RED}Warning: it looks like you might be using unscaled sizes.\\nIt is almost always preferable to defer to one of the predefined sizes in ui.size in the following files:"
        echo "${unscaled_size_check}"
        echo "${unscaled_size_check_geom}"
        exit_code=1
    fi

    tab_detected=$(grep -P "\\t" --include \*.lua --exclude={dateparser.lua,xml.lua} --recursive {reader,setupkoenv,datastorage}.lua frontend plugins spec || true)
    if [ "${tab_detected}" ]; then
        echo -e "\\n${ANSI_RED}Warning: tab character detected. Please use spaces."
        echo "${tab_detected}"
        exit_code=1
    fi

    untagged_todo=$(grep -Pin "[^\-]\-\-(\s+)?@?(todo|fixme|warning)" --include \*.lua --exclude={dateparser.lua,xml.lua} --recursive {reader,setupkoenv,datastorage}.lua frontend plugins spec || true)
    if [ "${untagged_todo}" ]; then
        echo -e "\\n${ANSI_RED}Warning: possible improperly tagged todo, fixme or warning detected."
        echo -e "\\n${ANSI_RED}         use --- followed by @todo, @fixme or @warning."
        echo "${untagged_todo}"
        exit_code=1
    fi

    echo -e "\n${ANSI_GREEN}Luacheck results"
    $(command -v luacheck) -q {reader,setupkoenv,datastorage}.lua frontend plugins spec

    exit "${exit_code}"
}

function kodev-cov() {
    CMD='cov'
    HELP="
usage: cov <OPTIONS>

OPTIONS:

    -f, --full                show full coverage report (down to each line)
    -s, --show-previous       show coverage stats from previous run
$(build_options_help_msg 'BUILD' 'use existing build' '' 'default')
"
    parse_options \
        "fs${BUILD_GETOPT_SHORT}" \
        "full,show-previous,${BUILD_GETOPT_LONG}" \
        '*' "$@"

    # Defaults
    local show_full=
    local show_previous=

    set -- "${OPTS[@]}"

    while [[ $# -gt 0 ]]; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#/}"
        case "${PARAM}" in
            -f | --full)
                show_full=1
                ;;
            -s | --show-previous)
                show_previous=1
                ;;
        esac
        shift
    done

    setup_target 'emulator'

    local margs=(
        ${NO_BUILD:+--assume-old=all}
        ${show_previous:+--assume-old=testcov-front}
        cov${show_full:+-full}
    )

    if [[ ${#ARGS[@]} -gt 0 ]]; then
        margs+=(TARGS="$(print_quoted "${ARGS[@]}")")
    fi

    run_make "${margs[@]}"
}

function kodev-log() {
    LOG_HELP_MSG="
usage: log <OPTIONS> <TARGET>

OPTIONS:

    -d, --debug               more verbose logs (e.g., debug builds)

TARGET:

    android
"
    [ $# -lt 1 ] && {
        echo "${LOG_HELP_MSG}"
        exit 1
    }

    # Defaults
    ignore_translation=0

    declare opt
    declare -r short_opts="dh"
    declare -r long_opts="debug, help"

    if ! opt=$(getopt -o "${short_opts}" --long "${long_opts}" --name "kodev" -- "${@}"); then
        echo "${LOG_HELP_MSG}"
        exit ${E_OPTERR}
    fi

    eval set -- "${opt}"

    while true; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#=/}"
        case "${PARAM}" in
            -d | --debug)
                export KODEBUG=1
                ;;
            -h | --help)
                echo "${LOG_HELP_MSG}"
                exit 0
                ;;
            --)
                break
                ;;
            *)
                echo "ERROR: unknown option \"${PARAM}\""
                echo "${RELEASE_HELP_MSG}"
                exit 1
                ;;
        esac
        shift
    done
    shift

    case "${1}" in
        android)
            if command -v pidcat >/dev/null; then
                if [ -n "${KODEBUG}" ]; then
                    pidcat "org.koreader.launcher"
                else
                    pidcat org.koreader.launcher --min-level=I
                fi
            else
                if [ -n "${KODEBUG}" ]; then
                    adb logcat 'KOReader:V ApkUpdater:V Assets:V Device:V dlopen:V EPD:V EventReceiver:V Lights:V Surface:V LuaJIT:V MainActivity:V NativeGlue:V NativeThread:V Timeout:V ActivityManager:V AndroidRuntime:V DEBUG:* *:F'
                else
                    adb logcat 'KOReader:I MainActivity:V NativeGlue:V NativeThread:V ActivityManager:W AndroidRuntime:E DEBUG:* *:F'
                fi
            fi
            ;;
        *)
            err "ERROR: unsupported target '$1'."
            echo "${LOG_HELP_MSG}"
            exit 1
            ;;
    esac
}

HELP_MSG="
usage: $0 COMMAND <ARGS>

Supported commands:

    activate            Bootstrap shell environment for kodev
    build               Build KOReader
    clean               Clean KOReader build
    fetch-thirdparty    Fetch thirdparty dependencies for build
    log                 Tail log stream for a running KOReader app
    release             Build KOReader release package
    run                 Run KOReader
    test                Run busted tests
    check               Run luacheck static-analysis
    cov                 Run busted tests for coverage
    wbuilder            Run wbuilder.lua script (useful for building new UI widget)
    prompt              Run a LuaJIT shell within KOReader's environment
"
[ $# -lt 1 ] && {
    echo "Missing command."
    echo "${HELP_MSG}"
    exit 1
}

case "${1}" in
    activate)
        echo "adding ${CURDIR} to \$PATH..."
        export PATH="${PATH}:${CURDIR}"
        eval "$(luarocks --lua-version 5.1 path --bin)"
        exec "${SHELL}"
        ;;
    fetch-thirdparty)
        kodev-fetch-thirdparty
        ;;
    clean)
        shift 1
        kodev-clean "$@"
        ;;
    build)
        shift 1
        kodev-build "$@"
        ;;
    release)
        shift 1
        kodev-release "$@"
        ;;
    wbuilder)
        shift 1
        kodev-wbuilder "$@"
        ;;
    run)
        shift 1
        kodev-run "$@"
        ;;
    test)
        shift 1
        kodev-test "$@"
        ;;
    check)
        shift 1
        kodev-check "$@"
        ;;
    cov)
        shift 1
        kodev-cov "$@"
        ;;
    prompt)
        kodev-build
        pushd "${EMU_DIR}" && {
            ./luajit -i setupkoenv.lua
        } && popd || exit
        ;;
    log)
        shift 1
        kodev-log "$@"
        ;;
    -h | --help)
        echo "${HELP_MSG}"
        exit 0
        ;;
    *)
        echo "Unknown command: $1."
        echo "${HELP_MSG}"
        exit 8
        ;;
esac

# vim: shiftwidth=4 softtabstop=4
