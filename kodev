#!/usr/bin/env bash

set -eo pipefail

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
    echo "incompatible bash version: ${BASH_VERSION}, need >=4.0"
    exit 1
fi

# shellcheck disable=2034
declare -r ANSI_BLUE=$'\e[34;1m'
# shellcheck disable=2034
declare -r ANSI_DIM=$'\e[2m'
# shellcheck disable=2034
declare -r ANSI_BROWN=$'\e[33;1m'
declare -r ANSI_GREEN=$'\e[32;1m'
declare -r ANSI_RED=$'\e[31;1m'
declare -r ANSI_RESET=$'\e[0m'
declare -r E_OPTERR=85

declare -r SHFMT_OPTIONS=(-i 4 -ci)

opt_dry_run=0
opt_timings=0

function info() {
    local color=ANSI_BLUE
    if [[ "$1" = -c* ]]; then
        color="ANSI_${1#-c}"
        shift
    fi
    if [[ -t 2 || "${CI}" = 'true' ]]; then
        echo "${!color}$*${ANSI_RESET}" 1>&2
    else
        echo "$*" 1>&2
    fi
}

function err() {
    info -cRED "$@"
}

function die() {
    local code=$?
    if [[ $# -ne 0 ]]; then
        code="$1"
        shift
    fi
    if [[ $# -ne 0 ]]; then
        err "$@"
    fi
    exit "${code}"
}

function print_quoted() {
    if [[ $# -ne 0 ]]; then
        printf '%q' "$1"
        shift
    fi
    if [[ $# -ne 0 ]]; then
        printf ' %q' "$@"
    fi
}

if [[ "${CI}" = 'true' ]]; then
    function faketty() {
        "$@"
    }
    if [[ ${OSTYPE} == darwin* ]] && which unbuffer &>/dev/null; then
        function faketty() {
            env TERM='xterm-256color' unbuffer "$@"
        }
    fi
    if [[ ${OSTYPE} == linux* ]] && which script &>/dev/null; then
        function faketty() {
            env TERM='xterm-256color' script /dev/null --quiet --return --command "$(print_quoted "$@")"
        }
    fi
fi

function run() {
    if [[ ${opt_dry_run} -eq 0 && "${CI}" = 'true' ]]; then
        echo -n '::group::' 1>&2
    fi
    info "$(print_quoted "$@")"
    if [[ ${opt_dry_run} -ne 0 ]]; then
        return
    fi
    local cmd=("$@")
    if [[ "${CI}" == 'true' ]]; then
        # For color output…
        cmd=(faketty "${cmd[@]}")
    fi
    local code=0
    if [[ ${opt_timings} -ne 0 ]]; then
        time "${cmd[@]}" || code=$?
    else
        "${cmd[@]}" || code=$?
    fi
    if [ "${CI}" = 'true' ]; then
        info -cDIM "$(print_quoted "$@")"
        echo '::endgroup::' 1>&2
    fi
    return ${code}
}

function run_make() {
    local cmd=(make)
    if [[ ${opt_dry_run} -ne 0 ]]; then
        cmd+=(-n)
    fi
    if [[ "${CURDIR}" != "${PWD}" ]]; then
        cmd+=(-C "${CURDIR}")
    fi
    for param in TARGET KODEBUG VERBOSE; do
        cmd+=("${param}=${!param}")
    done
    cmd+=("$@")
    opt_dry_run=0 run "${cmd[@]}"
}

function setenv() {
    info "$(printf 'export %q\n' "$@")"
    # shellcheck disable=SC2163
    export "$@"
    if [[ "${CI}" == 'true' && -n "${GITHUB_ENV}" ]]; then
        printf '%q\n' "$@" >>"${GITHUB_ENV}"
    fi
}

function addpath() {
    info "export PATH=$(print_quoted "$1"):\"\$PATH\""
    export PATH="$1:${PATH}"
    if [[ "${CI}" == 'true' && -n "${GITHUB_PATH}" ]]; then
        printf '%s\n' "$1" >>"${GITHUB_PATH}"
    fi
}

function download() {
    run wget --continue --no-verbose --progress=dot:mega --show-progress "$@"
}

CURDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

function setup_target() {
    TARGET="$1"
    shift 1
    local valid=1
    case "${TARGET}" in
        # Emulator.
        '')
            if [[ "${CMD}" == 'release' ]]; then
                valid=0
            fi
            TARGET='emulator'
            ;;
        emulator*)
            if [[ "${CMD}" == 'release' ]]; then
                valid=0
            fi
            ;;
        appimage)
            if [[ "${CMD}" != 'release' ]]; then
                valid=0
            fi
            TARGET='emulator'
            ;;
        # Devices.
        android-*) ;;
        kindlepw2) ;;
        *)
            valid=0
            ;;
    esac
    if [[ "${valid}" -eq 0 ]]; then
        err "ERROR: unsupported ${CMD} target \"${TARGET}\"."
        echo "${HELP}"
        exit 1
    fi
    if [[ -z ${KODEBUG+x} && "${TARGET}" = emulator* && "${CMD}" != 'release' ]]; then
        # For the emulator, build a debug build by default.
        KODEBUG=1
    fi
}

function kodev-fetch-thirdparty() {
    run_make fetch-thirdparty
}

declare -r TARGETS_HELP_MSG="
TARGET:

    android-arm
    android-arm64
    android-x86
    android-x86_64
    kindlepw2       for Kindle models >= Paperwhite 2
    emulator        default if no TARGET is given"

declare -r RELEASE_TARGETS_HELP_MSG="${TARGETS_HELP_MSG/emu*/""}appimage"

declare -r BUILD_GETOPT_SHORT='bdnv'
declare -r BUILD_GETOPT_LONG='no-build,debug,no-debug,verbose'

function build_options_help_msg() {
    local section="$1"
    local no_build_details="$2"
    local debug_details="$3"
    local no_debug_details="$4"
    echo "
${section}${section:+ }OPTIONS:

    ${no_build_details:+-b, --no-build            do not build (}${no_build_details}${no_build_details:+)
    }-d, --debug               enable debugging symbols${debug_details:+ (}${debug_details}${debug_details:+)}
    -n, --no-debug            no debugging symbols${no_debug_details:+ (}${no_debug_details}${no_debug_details:+)}
    -v, --verbose             make the build system more verbose
"
}

function parse_options() {
    local short_opts="$1"
    local long_opts="$2"
    local args_spec="$3"
    shift 3
    # First things first: check if getopt is a compatible (util-linux like) version.
    if getopt -T >/dev/null 2>&1 || [[ $? -ne 4 ]]; then
        die 1 "unsupported getopt version: $(getopt --version)"
    fi
    if ! opt=$(getopt -o "h${short_opts}" --long "help,${long_opts}" --name "kodev" -- "$@"); then
        echo "${HELP}"
        exit ${E_OPTERR}
    fi
    # echo "opt: $opt"
    eval set -- "${opt}"
    OPTS=()
    ARGS=()
    while true; do
        case "$1" in
            -h | --help)
                echo "${HELP}"
                exit 0
                ;;
            -b | --no-build)
                NO_BUILD=1
                ;;
            -d | --debug)
                KODEBUG=1
                ;;
            -n | --no-debug)
                KODEBUG=
                ;;
            -v | --verbose)
                # shellcheck disable=SC2034
                VERBOSE=1
                ;;
            --)
                shift
                break
                ;;
            *)
                OPTS+=("$1")
                ;;
        esac
        shift
    done
    local expected
    local valid=0
    case "${args_spec}" in
        '*') ;;
        '+')
            expected='1 or more'
            [[ $# -ge 1 ]] || valid=1
            ;;
        '?')
            expected='1 optional'
            [[ $# -le 1 ]] || valid=1
            ;;
        *)
            expected="${args_spec}"
            [[ $# -eq "${args_spec}" ]] || valid=1
            ;;
    esac
    if [[ ${valid} -ne 0 ]]; then
        err "ERROR: invalid ${CMD} arguments; ${expected} expected but $# received"
        echo "${HELP}"
        exit 8
    fi
    ARGS=("$@")
    # echo "OPTS: ${OPTS[@]} [${#OPTS[@]}]"
    # echo "ARGS: ${ARGS[@]} [${#ARGS[@]}]"
}

function kodev-build() {
    CMD='build'
    HELP="
usage: build <OPTIONS> <TARGET>
$(build_options_help_msg '' 'stop after the setup phase' 'default for emulator' 'default for target devices')
${TARGETS_HELP_MSG}
"
    parse_options \
        "h${BUILD_GETOPT_SHORT}" \
        "help,${BUILD_GETOPT_LONG}" \
        '?' "$@"
    setup_target "${ARGS[0]}" 'build'
    run_make ${NO_BUILD:+setup}
}

function kodev-clean() {
    CMD='clean'
    HELP="
usage: clean <TARGET>
$(build_options_help_msg '' '' 'clean debug build' 'clean release build')
${TARGETS_HELP_MSG}
"
    parse_options \
        "h${BUILD_GETOPT_SHORT/b/}" \
        "help,${BUILD_GETOPT_LONG/no-build,/}" \
        '?' "$@"
    setup_target "${ARGS[0]}" 'clean'
    run_make clean
}

function kodev-release() {
    CMD='release'
    HELP="
usage: release <OPTIONS> <TARGET>

OPTIONS:

    -i, --ignore-translation  do not fetch translation for release

$(build_options_help_msg 'BUILD' 'create update from existing build' '' 'default')

${RELEASE_TARGETS_HELP_MSG}
"
    parse_options \
        "ih${BUILD_GETOPT_SHORT}" \
        "ignore-translation,help,${BUILD_GETOPT_LONG}" \
        '1' "$@"

    local ignore_translation=0
    for opt in "${OPTS[@]}"; do
        case "${opt}" in
            -i | --ignore-translation)
                ignore_translation=1
                ;;
        esac
    done

    local update='update'
    if [[ "${ARGS[0]}" == 'appimage' ]]; then
        update='appimageupdate'
    fi

    setup_target "${ARGS[0]}"

    if [ "${ignore_translation}" -eq 0 ]; then
        run_make po || {
            echo "ERROR: failed to fetch translation."
            echo "Tip: Use --ignore-translation OPTION if you want to build a release without translation."
            exit 1
        }
    fi

    run_make ${NO_BUILD:+--assume-old=all --assume-old=install} "${update}"
}

function kodev-wbuilder() {
    CMD='wbuilder'
    HELP="
usage: wbuilder
    "
    parse_options '' '' 0 "$@"
    setup_target 'emulator'
    echo "[*] Running wbuilder.lua..."
    run_make RPREFIX='EMULATE_READER_W=540 EMULATE_READER_H=720' run-wbuilder
}

function kodev-run() {
    VALGRIND=(valgrind --keep-debuginfo=yes --tool=memcheck --trace-children=yes --leak-check=full --track-origins=yes --show-reachable=yes)
    if [[ -r valgrind.sup ]]; then
        VALGRIND+=(--suppressions="${PWD}/valgrind.sup")
    fi
    CALLGRIND=(valgrind --tool=callgrind --trace-children=yes)
    # NOTE: Speaking of Valgrind, if your libdrm/mesa isn't built w/ valgrind markings, there's a Valgrind suppression file for AMD cards in the tools folder.
    #       Just append --suppressions=${PWD/tools/valgrind_amd.supp to your valgrind command.
    CMD='run'
    HELP="
usage: run <OPTIONS> <EMULATOR ARGS>
       run <OPTIONS> <ANDROID TARGET> [ANDROID APK]
$(build_options_help_msg '' 'use existing build' 'default for emulator' 'default for android target')

EMULATOR OPTIONS:

    -H X, --screen-height=X  set height of the emulator screen (default: 720)
    -W X, --screen-width=X   set width of the emulator screen (default: 540)
    -D X, --screen-dpi=X     set DPI of the emulator screen (default: 160)
    -t, --disable-touch      use this if you want to simulate keyboard only devices
    -s FOO --simulate=FOO    simulate dimension and other specs of the given device:
                             hidpi, kindle, kindle-paperwhite, kobo-aura-one, kobo-clara,
                             kobo-forma, kobo-h2o or legacy-paperwhite.
    -g X, --gdb=X            run with debugger (default: nemiver)
    -c, --callgrind          run with valgrind's callgrind (\`$(print_quoted "${CALLGRIND[@]}")\`)
    --valgrind=X             run with valgrind (default: \`$(print_quoted "${VALGRIND[@]}")\`)

    Extra arguments are forwarded to the emulator.

ANDROID TARGET:

    Install and run KOReader on an Android device connected through ADB.

    Supported targets: android-arm, android-arm64, android-x86 and android-x86_64.
"
    parse_options \
        "tg:::cW:H:D:s:${BUILD_GETOPT_SHORT}" \
        "disable-touch,gdb::,valgrind::,callgrind,screen-width:,screen-height:,screen-dpi:,simulate:,${BUILD_GETOPT_LONG}" \
        '*' "$@"

    # Defaults
    screen_width=540
    screen_height=720

    set -- "${OPTS[@]}"

    while [[ $# -gt 0 ]]; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#=/}"
        case "${PARAM}" in
            -t | --disable-touch)
                export DISABLE_TOUCH=1
                ;;
            -g | --gdb)
                if [ -n "${VALUE}" ]; then
                    read -r -a gdb <<<"${VALUE}"
                else
                    # Try to use friendly defaults for gdb
                    if command -v nemiver >/dev/null; then
                        # Nemiver is a nice GUI
                        gdb=(nemiver)
                    elif command -v ddd >/dev/null; then
                        # DDD is a slightly less nice GUI
                        gdb=(ddd)
                    elif command -v cgdb >/dev/null; then
                        # cgdb is a nice curses-based gdb front
                        gdb=(cgdb)
                    elif command -v gdb >/dev/null; then
                        # gdb -tui is a slightly less nice terminal user interface
                        gdb=(gdb -tui)
                    else
                        echo "Couldn't find gdb."
                        exit 1
                    fi
                fi
                shift
                ;;
            --valgrind)
                if [ -n "${VALUE}" ]; then
                    read -r -a valgrind <<<"${VALUE}"
                else
                    # Try to use sensible defaults for valgrind
                    if command -v valgrind >/dev/null; then
                        valgrind=("${VALGRIND[@]}")
                    else
                        echo "Couldn't find valgrind."
                        exit 1
                    fi
                fi
                shift
                ;;
            -c | --callgrind)
                # Try to use sensible defaults for valgrind
                if command -v valgrind >/dev/null; then
                    valgrind=("${CALLGRIND[@]}")
                else
                    echo "Couldn't find valgrind."
                    exit 1
                fi
                ;;
            -W | --screen-width)
                screen_width=${VALUE}
                shift
                ;;
            -H | --screen-height)
                screen_height=${VALUE}
                shift
                ;;
            -D | --screen-dpi)
                screen_dpi=${VALUE}
                shift
                ;;
            -s | --simulate)
                device_model="${VALUE}"
                case "${device_model}" in
                    kindle)
                        screen_width=600
                        screen_height=800
                        screen_dpi=167
                        ;;
                    legacy-paperwhite)
                        screen_width=758
                        screen_height=1024
                        screen_dpi=212
                        ;;
                    kobo-forma)
                        screen_width=1440
                        screen_height=1920
                        screen_dpi=300
                        ;;
                    kobo-aura-one)
                        screen_width=1404
                        screen_height=1872
                        screen_dpi=300
                        ;;
                    kobo-clara | kindle-paperwhite)
                        screen_width=1072
                        screen_height=1448
                        screen_dpi=300
                        ;;
                    kobo-h2o)
                        screen_width=1080
                        screen_height=1429
                        screen_dpi=265
                        ;;
                    hidpi)
                        screen_width=1500
                        screen_height=2000
                        screen_dpi=600
                        ;;
                    *)
                        echo "ERROR: spec unknown for ${device_model}."
                        ;;
                esac
                shift
                ;;
        esac
        shift
    done

    set -- "${ARGS[@]}"

    local target=''
    case "$1" in
        android*)
            target="$1"
            shift
            ;;
    esac

    setup_target "${target}" 'run' "${RUN_HELP_MSG}"

    local rprefix=()

    if [[ -z "${target}" ]]; then
        rprefix+=(EMULATE_READER_W="${screen_width}" EMULATE_READER_H="${screen_height}" EMULATE_READER_DPI="${screen_dpi}")
    fi

    if [[ "${#valgrind}" -gt 0 ]]; then
        rprefix+=("${valgrind[@]}")
    fi

    if [[ "${#gdb}" -gt 0 ]]; then
        # We don't want to stack valgrind on top of GDB ;).
        if [[ "${gdb[0]}" == gdb* ]]; then
            # The standard CLI needs a little hand holding to properly pass arguments to the process it'll monitor
            rprefix+=("${gdb[@]}" --args)
        else
            rprefix+=("${gdb[@]}")
        fi
    fi

    local margs=()

    if [[ "${target}" = android-* ]]; then
        if [[ "$1" = *.apk ]]; then
            margs+=(ANDROID_APK="$1")
            NO_BUILD=1
            shift
        fi
        if [[ ${#rprefix[@]} -gt 0 || $# -gt 0 ]]; then
            echo "${RUN_HELP_MSG}"
            exit ${E_OPTERR}
        fi
    fi

    local rargs=()

    for a in "$@"; do
        if [[ "${a}" != [-/]* ]]; then
            a="${PWD}/${a}"
        fi
        rargs+=("${a}")
    done

    if [[ ${#rprefix[@]} -gt 0 ]]; then
        margs+=(RPREFIX="$(print_quoted "${rprefix[@]}")")
    fi

    if [[ ${#rargs} -gt 0 ]]; then
        margs+=(RARGS="$(print_quoted "${rargs[@]}")")
    fi

    run_make "${margs[@]}" ${NO_BUILD:+--assume-old=all --assume-old=update} run
}

function kodev-test() {
    # shellcheck disable=SC1091
    source ./subprojects/koreader-runtests/runtests
    CMD='test'
    HELP="
usage: test <OPTIONS> <TEST_SUITE> <TEST_NAMES>

    TEST_SUITE: [all|base|bench|front]. Optional: detault to all.

    TEST_NAMES: if no TEST_NAMES are given, the full testsuite is run.
${RUNTESTS_HELP}$(build_options_help_msg 'BUILD' 'use existing build' '' 'default')
"
    parse_options \
        "${RUNTESTS_GETOPT_SHORT},${BUILD_GETOPT_SHORT}" \
        "${RUNTESTS_GETOPT_LONG},${BUILD_GETOPT_LONG}" \
        '*' "$@"

    local targs=()
    # Optional argument options must be rewritten
    # so they are correctly forwarded to runtests:
    # `--opt val` -> `--opt=val`
    set -- "${OPTS[@]}"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --busted | --meson)
                targs+=("$1=$2")
                shift
                ;;
            *) targs+=("$1") ;;
        esac
        shift
    done
    targs+=("${ARGS[@]}")

    setup_target 'emulator'

    local margs=(runtests)
    if [[ ${#targs[@]} -gt 0 ]]; then
        margs+=(TARGS="$(print_quoted "${targs[@]}")")
    fi
    run_make ${NO_BUILD:+--assume-old=all} "${margs[@]}"
}

function check-shell() {
    local output
    local -a issues=()
    local warn="${ANSI_RED}Warning${ANSI_RESET}"
    local shellcheck=(shellcheck --color=always)
    local shfmt=(env FORCE_COLOR=1 shfmt "${SHFMT_OPTIONS[@]}")
    printf '%s: ' "$1"
    # Checking code quality.
    if ! output="$("${shellcheck[@]}" "$1")"; then
        issues+=("${output}")
    fi
    # Checking formatting.
    if ! output="$("${shfmt[@]}" -kp -d "$1")"; then
        issues+=($'\n'"${warn}: $1 does not abide by coding style, diff for expected style:")
        issues+=("${output}")
    fi
    if [[ ${#issues[@]} -eq 0 ]]; then
        echo "${ANSI_GREEN}OK${ANSI_RESET}"
        return 0
    else
        echo "${ANSI_RED}KO${ANSI_RESET}"
        printf '%s\n' "${issues[@]}"
        return 1
    fi
}

function check-lua() {
    local output
    local -a issues=()
    local warn="${ANSI_RED}Warning${ANSI_RESET}"
    printf '%s: ' "$1"
    # Checking for unscaled sizes.
    output=''
    case "$1" in
        base/*) ;;
        frontend/ui/data/keyboardlayouts/*) ;;
        frontend/ui/data/koptoptions.lua) ;;
        *)
            output="$(grep --color=always -n '\(padding\|margin\|bordersize\|width\|height\|radius\|linesize\) = [0-9]\{1,2\}' "$1" |
                      grep -v '= 0' | grep -v '= [0-9]/[0-9]' | grep -Ev '(default_option_height|default_option_padding)' |
                      grep -v scaleBySize | grep -v 'unscaled_size_check: ignore' || true)"
            ;;
    esac
    # Also check for Geom objects.
    case "$1" in
        base/*) ;;
        spec/unit/gesturerange_spec.lua) ;;
        *)
            [[ -z "${output}" ]] || output+=$'\n\n'
            output+="$(grep --color=always -En 'Geom:new{.+ [wh] = [0-9]{1,4}' "$1" |
                      grep -Ev '[wh] = 0' | grep -v '= [0-9]/[0-9]' |
                      grep -v scaleBySize || true)"
            ;;
    esac
    if [[ -n "${output}" ]]; then
        issues+=(
            ''
            "${warn}: it looks like you might be using unscaled sizes. It is almost"
            "always preferable to defer to one of the predefined sizes in ui.size:"
            ''
            "${output}"
            ''
        )
    fi
    # Checking for tabs.
    output=''
    case "$1" in
        plugins/newsdownloader.koplugin/lib/dateparser.lua) ;;
        plugins/newsdownloader.koplugin/lib/xml.lua) ;;
        *)
            output="$(env GREP_COLORS='ms=41' grep --color=always -nP '\t+' "$1" || true)"
            ;;
    esac
    if [[ -n "${output}" ]]; then
        issues+=(
            ''
            "${warn}: tab character detected. Please use spaces:"
            ''
            "${output}"
            ''
        )
    fi
    # Check for untagged FIXMEs / TODOs / warnings.
    output=''
    case "$1" in
        plugins/newsdownloader.koplugin/lib/dateparser.lua) ;;
        plugins/newsdownloader.koplugin/lib/xml.lua) ;;
        *)
            output="$(grep --color=always -Pin '[^\-]--(\s+)?@?(todo|fixme|warning)' "$1" || true)"
            ;;
    esac
    if [[ -n "${output}" ]]; then
        issues+=(
            ''
            "${warn}: possible improperly tagged todo, fixme or warning"
            'detected, use --- followed by @todo, @fixme or @warning:'
            ''
            "${output}"
            ''
        )
    fi
    case "$1" in
        base/libkoreader.meson.lua) ;;
        *)
            if ! output="$(luacheck --codes --quiet "$1")"; then
                issues+=($'\n'"${output}"$'\n')
            fi
            ;;
    esac
    if [[ ${#issues[@]} -eq 0 ]]; then
        echo "${ANSI_GREEN}OK${ANSI_RESET}"
        return 0
    else
        echo "${ANSI_RED}KO${ANSI_RESET}"
        printf '%s\n' "${issues[@]}"
        return 1
    fi
}

function list-files() {
    local -a files
    local glob="$1"
    local shebang="$2"
    shift 2
    for repo in "$@"; do
        mapfile -t files < <(
            git -C "${repo}" -c submodule.recurse=0 grep -lE "${shebang}" || true
            git -C "${repo}" ls-files "${glob}"
        )
        if [[ "${repo}" != '.' ]]; then
            files=("${files[@]/#/${repo}/}")
        fi
        printf '%s\n' "${files[@]}"
    done
}

function kodev-check() {
    local SHELL_GLOB='*.sh'
    local SHELL_SHEBANG='^#!(/usr)?/bin/(env )?(bash|sh)'
    local LUA_GLOB='*.lua'
    local LUA_SHEBANG='^#!(/usr)?/bin/(env )?lua(jit)?'
    local -a shellscripts
    local -a luafiles
    local parallel=0
    local exit_code=0

    if [[ -z "${PARALLEL_SEQ}" ]] && which parallel >/dev/null 2>&1; then
        parallel=1
    fi

    if [[ $# -eq 0 ]]; then
        # kodev-fetch-thirdparty
        local -a repos=(. subprojects/koreader-runtests)
        if [[ -d subprojects/luajit-launcher ]]; then
            repos+=(subprojects/luajit-launcher)
        fi
        mapfile -t shellscripts < <(
            list-files "${SHELL_GLOB}" "${SHELL_SHEBANG}" "${repos[@]}" |
                grep -vE '^(plugins/terminal\.koplugin/shfm|subprojects/crengine/.*|subprojects/luajit-launcher/gradlew)$' | sort -u
        )
        mapfile -t luafiles < <(
            list-files "${LUA_GLOB}" "${LUA_SHEBANG}" "${repos[@]}" |
                grep -vE '^base/ffi/.*_h\.lua$' | sort -u
        )
    else
        for arg in "$@"; do
            # shellcheck disable=2254
            case "${arg}" in
                ${LUA_GLOB})
                    luafiles+=("${arg}")
                    ;;
                ${SHELL_GLOB})
                    shellscripts+=("${arg}")
                    ;;
                *)
                    if grep -qE "${LUA_SHEBANG}" "${arg}"; then
                        luafiles+=("${arg}")
                    elif grep -qE "${SHELL_SHEBANG}" "${arg}"; then
                        shellscripts+=("${arg}")
                    else
                        die 1 "unsupported file type: \"${arg}\""
                    fi
                    ;;
            esac
        done
    fi

    if [[ ${#shellscripts[@]} -gt 0 && ${parallel} -eq 1 ]]; then
        parallel --keep-order --line-buffer ./kodev check ::: "${shellscripts[@]}" || exit_code=1
    else
        for f in "${shellscripts[@]}"; do
            check-shell "${f}" || exit_code=1
        done
    fi

    if [[ ${#luafiles[@]} -gt 0 && ${parallel} -eq 1 ]]; then
        parallel --keep-order --line-buffer ./kodev check ::: "${luafiles[@]}" || exit_code=1
    else
        for f in "${luafiles[@]}"; do
            check-lua "${f}" || exit_code=1
        done
    fi

    exit "${exit_code}"
}

function kodev-cov() {
    CMD='cov'
    HELP="
usage: cov <OPTIONS>

OPTIONS:

    -f, --full                show full coverage report (down to each line)
    -s, --show-previous       show coverage stats from previous run
$(build_options_help_msg 'BUILD' 'use existing build' '' 'default')
"
    parse_options \
        "fs${BUILD_GETOPT_SHORT}" \
        "full,show-previous,${BUILD_GETOPT_LONG}" \
        '*' "$@"

    # Defaults
    local show_full=
    local show_previous=

    set -- "${OPTS[@]}"

    while [[ $# -gt 0 ]]; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#/}"
        case "${PARAM}" in
            -f | --full)
                show_full=1
                ;;
            -s | --show-previous)
                show_previous=1
                ;;
        esac
        shift
    done

    setup_target 'emulator'

    local margs=(
        ${NO_BUILD:+--assume-old=all}
        ${show_previous:+--assume-old=testcov-front}
        cov${show_full:+-full}
    )

    if [[ ${#ARGS[@]} -gt 0 ]]; then
        margs+=(TARGS="$(print_quoted "${ARGS[@]}")")
    fi

    run_make "${margs[@]}"
}

function kodev-log() {
    LOG_HELP_MSG="
usage: log <OPTIONS> <TARGET>

OPTIONS:

    -d, --debug               more verbose logs (e.g., debug builds)

TARGET:

    android
"
    [ $# -lt 1 ] && {
        echo "${LOG_HELP_MSG}"
        exit 1
    }

    # Defaults
    ignore_translation=0

    declare opt
    declare -r short_opts="dh"
    declare -r long_opts="debug, help"

    if ! opt=$(getopt -o "${short_opts}" --long "${long_opts}" --name "kodev" -- "${@}"); then
        echo "${LOG_HELP_MSG}"
        exit ${E_OPTERR}
    fi

    eval set -- "${opt}"

    while true; do
        PARAM="${1}"
        # Support using an = assignment with short options (e.g., -f=blah instead of -f blah).
        VALUE="${2/#=/}"
        case "${PARAM}" in
            -d | --debug)
                export KODEBUG=1
                ;;
            -h | --help)
                echo "${LOG_HELP_MSG}"
                exit 0
                ;;
            --)
                break
                ;;
            *)
                echo "ERROR: unknown option \"${PARAM}\""
                echo "${RELEASE_HELP_MSG}"
                exit 1
                ;;
        esac
        shift
    done
    shift

    case "${1}" in
        android)
            if command -v pidcat >/dev/null; then
                if [ -n "${KODEBUG}" ]; then
                    pidcat "org.koreader.launcher"
                else
                    pidcat org.koreader.launcher --min-level=I
                fi
            else
                if [ -n "${KODEBUG}" ]; then
                    adb logcat 'KOReader:V ApkUpdater:V Assets:V Device:V dlopen:V EPD:V EventReceiver:V Lights:V Surface:V LuaJIT:V MainActivity:V NativeGlue:V NativeThread:V Timeout:V ActivityManager:V AndroidRuntime:V DEBUG:* *:F'
                else
                    adb logcat 'KOReader:I MainActivity:V NativeGlue:V NativeThread:V ActivityManager:W AndroidRuntime:E DEBUG:* *:F'
                fi
            fi
            ;;
        *)
            err "ERROR: unsupported target '$1'."
            echo "${LOG_HELP_MSG}"
            exit 1
            ;;
    esac
}

function kodev-ci-add-job-parameters() {
    local decls
    decls="$(printf 'readonly %q\n' "${@/#/JOB_}")"
    info "${decls}"
    echo "${decls}" >>job.sh
}

function kodev-ci-func-banner() {
    info -cGREEN "${FUNCNAME[1]}"
}

function kodev-ci-fetch-submodules() {
    kodev-ci-func-banner
    run sh -c 'git submodule update --init --depth 1 --jobs 3 2>&1 | cat'
}

function kodev-ci-fetch-thirdparty() {
    kodev-ci-func-banner
    run_make fetch-thirdparty
    run_make trim-thirdparty
}

function kodev-ci-install-7z() {
    kodev-ci-func-banner
    local dist="linux-p7zip.7z"
    download "https://github.com/p7zip-project/p7zip/releases/download/v${JOB_7Z_VERSION}/${dist}"
    run 7z -o7z x "${PWD}/${dist}"
    run rm "${dist}"
    addpath "${PWD}/7z"
}

function kodev-ci-install-ndk() {
    if [[ -d ndk ]]; then
        return
    fi
    local ndk_dist="android-ndk-${JOB_NDK_VERSION}-linux.zip"
    download "https://dl.google.com/android/repository/${ndk_dist}"
    unzip -q "${ndk_dist}"
    mv "${ndk_dist%-linux.zip}" ndk
    pushd ndk
    hardlink .
    rm -vrf prebuilt/android-*
    rm -vrf shader-tools simpleperf
    rm -vrf sources/third_party
    rm -vrf toolchains/renderscript
    pushd toolchains/llvm/prebuilt/linux-x86_64/sysroot/usr/lib
    rm -vrf aarch64-linux-android/2[^1]*
    rm -vrf aarch64-linux-android/[3-9]*
    rm -vrf arm-linux-androideabi/1[^8]*
    rm -vrf arm-linux-androideabi/[2-9]*
    rm -vrf i686-linux-android/1[^8]
    rm -vrf i686-linux-android/[2-9]*
    rm -vrf x86_64-linux-android/2[^1]*
    rm -vrf x86_64-linux-android/[3-9]*
    popd
    find . -name 'libomp.*' -print0 | xargs -0 rm -v
    find . -name 'libFuzzer.*' -print0 | xargs -0 rm -v
    find . -name 'libclang_rt.*' -print0 | /usr/bin/grep -E --null-data '/libclang_rt\.(\w+san|fuzzer|profile|scudo|stats)' | xargs -0 rm -v
    popd
}

function kodev-ci-install-x-tools() {
    kodev-ci-func-banner
    download "https://github.com/koreader/koxtoolchain/releases/download/2021.12/$1.zip"
    run 7z e "$1.zip"
    run tar x${JOB_RUNNER_DEBUG:+v}af "$1.tar.gz" -C ..
    addpath "${PWD%/*}/x-tools/$2/bin"
}

function kodev-ci-install-reqs-linux() {
    kodev-ci-func-banner
    local need_7z=0
    local packages=("$@")
    local xtools=()
    case "${JOB_TARGET}" in
        android-arm)
            if [[ "${JOB_BUILDING}" == 'true' ]]; then
                packages+=(
                    gcc-multilib
                )
            fi
            need_7z=1
            ;;
        android-arm64)
            need_7z=1
            ;;
        android-x86)
            if [[ "${JOB_BUILDING}" == 'true' ]]; then
                packages+=(
                    gcc-multilib
                    nasm
                )
            fi
            need_7z=1
            ;;
        emulator*)
            packages+=(
                libsdl2-2.0-0
            )
            if [[ "${JOB_BUILDING}" == 'true' ]]; then
                packages+=(
                    libbsd0
                    libegl1-mesa-dev
                    libgl1-mesa-dev
                    libgles2-mesa-dev
                    libvulkan-dev
                    libwayland-dev
                    libx11-dev
                    libxcursor-dev
                    libxi-dev
                    libxkbcommon-dev
                    libxrandr-dev
                    nasm
                    wayland-protocols
                )
            fi
            ;;
        kindlepw2)
            if [[ "${JOB_BUILDING}" == 'true' ]]; then
                packages+=(
                    gcc-multilib
                    zsync
                )
                xtools=(kindlepw2 arm-kindlepw2-linux-gnueabi)
            fi
            ;;
    esac
    if [[ ${#packages} -gt 0 ]]; then
        run sudo rm -f /var/lib/man-db/auto-update
        run sudo apt -q update
        run sudo apt -qy install --no-install-recommends "${packages[@]}"
    fi
    if [[ ${#xtools} -gt 0 ]]; then
        kodev-ci-install-x-tools "${xtools[@]}"
    fi
    if [[ ${need_7z} -eq 1 && -n "${JOB_7Z_VERSION}" ]]; then
        kodev-ci-install-7z
    fi
}

function kodev-ci-install-reqs() {
    kodev-ci-func-banner
    case "${RUNNER_OS}" in
        'Linux')
            kodev-ci-install-reqs-linux "$@"
            ;;
    esac
    kodev-ci-install-meson
    if [[ "${JOB_BUILDING}" != 'true' ]]; then
        return
    fi
    kodev-ci-install-ccache
    kodev-ci-install-ninja
}

function kodev-ci-install-ccache() {
    kodev-ci-func-banner
    local dist_flavor
    local dist_ext
    local tar
    case "${RUNNER_OS}" in
        'Linux')
            dist_flavor='linux-x86_64'
            dist_ext='tar.xz'
            tar='tar'
            ;;
        *)
            die 1 "unsupported runner OS: \"${RUNNER_OS}\""
            ;;
    esac
    local dist="ccache-${JOB_CCACHE_VERSION}-${dist_flavor}"
    download "https://github.com/ccache/ccache/releases/download/v${JOB_CCACHE_VERSION}/${dist}.${dist_ext}"
    run "${tar}" x${JOB_RUNNER_DEBUG:+v}af "${dist}.${dist_ext}" -C ..
    run rm "${dist}.${dist_ext}"
    addpath "${PWD%/*}/${dist}"
}

function kodev-ci-install-meson() {
    kodev-ci-func-banner
    run python -m pip --disable-pip-version-check install "meson==${JOB_MESON_VERSION}"
}

function kodev-ci-install-ninja() {
    kodev-ci-func-banner
    local dist='ninja-linux.zip'
    download "https://github.com/ninja-build/ninja/releases/download/v${JOB_NINJA_VERSION}/${dist}"
    run mkdir ../ninja
    unzip -d ../ninja ninja-linux.zip
    run rm "${dist}"
    addpath "${PWD%/*}/ninja"
}

function kodev-ci-ccache-post-restore() {
    kodev-ci-func-banner
    run ccache --show-stats --verbose
    run ccache --zero-stats
    run ccache --show-config
}

function kodev-ci-ccache-pre-save() {
    kodev-ci-func-banner
    local primary_key="$1"
    run ccache --show-stats --verbose
    run ccache --max-size=256M
    run ccache --cleanup >/dev/null
    run ccache --show-stats --verbose
    setenv CCACHE_CACHE_KEY="${primary_key}-＿$(date '+%s')"
}

function kodev-ci-cache-cleanup() {
    kodev-ci-func-banner
    local cache='cache.json'
    local gh_api_cmd=(
        gh api
        -H "Accept: application/vnd.github+json"
        -H "X-GitHub-Api-Version: 2022-11-28"
    )
    local gh_api_url="/repos/${JOB_GITHUB_REPO}/actions/caches"
    if ! "${gh_api_cmd[@]}" "${gh_api_url}?ref=${JOB_GITHUB_REF}&per_page=100" >"${cache}"; then
        echo '::warning::failed to list cache entries'
        return
    fi
    run sh -c "jq . <${cache}"
    # Keep only the last ccache entry, the last main gradle cache
    # entry and the last 3 entries for all other cache types.
    local filters=(
        "1:${JOB_CACHE_EPOCH}＿${CACHE_KEY_PREFIX}＿ccache＿"
        "3:${JOB_CACHE_EPOCH}＿${CACHE_KEY_PREFIX}＿build＿"
        "3:${JOB_CACHE_EPOCH}＿subprojects＿"
    )
    if [[ "${JOB_TARGET}" = android-* ]]; then
        filters+=(
            "3:dependencies-"
            "3:instrumented-jars-"
        )
    fi
    local idlist
    set --
    for spec in "${filters[@]}"; do
        read -ra idlist < <(jq -r --argjson idx "${spec%%:*}" --arg key "${spec#*:}" \
            '.actions_caches | map(select(.key|startswith($key)).id)[$idx:] | join(" ")' \
            <"${cache}")
        info -cBROWN "${spec#*:}${ANSI_RESET} ${idlist[*]}"
        set -- "$@" "${idlist[@]}"
    done
    if [[ "${JOB_TARGET}" = android-* ]]; then
        read -ra idlist < <(jq -r '
            .actions_caches | map(select(.key|startswith("v9-gradle"))) |
            group_by(.key|sub("^[^|]+[|](?<k>.+)-[^-]+$"; "\(.k)")) |
            map(.[1:]) | flatten | map(.id) | join(" ")
            ' <"${cache}")
        info -cBROWN "v9-gradle${ANSI_RESET} ${idlist[*]}"
        set -- "$@" "${idlist[@]}"
    fi
    for id in "$@"; do
        run "${gh_api_cmd[@]}" --method DELETE "${gh_api_url}/${id}" || true
    done
}

function kodev-ci-setup-cache-key() {
    kodev-ci-func-banner
    run_make CCACHE=ccache TARGET="${JOB_TARGET}" cache-key
    run cat cache_key.txt
    setenv CACHE_KEY_HASH="$(git hash-object cache_key.txt)"
    setenv CACHE_KEY_PREFIX="${JOB_TARGET}${JOB_CACHE_EXTRA_KEY:+＿}${JOB_CACHE_EXTRA_KEY}"
}

function kodev-ci-build() {
    kodev-ci-func-banner
    # Note: split setup & build phases for easier logs introspection.
    local build_cmd=(kodev-build ${JOB_RUNNER_DEBUG:+--verbose} --no-debug "${JOB_TARGET}")
    # Setup.
    ("${build_cmd[@]}" --no-build)
    # Build.
    (NINJAFLAGS="${JOB_RUNNER_DEBUG:---quiet}" "${build_cmd[@]}")
}

function kodev-ci-coredumps-handle-linux() {
    kodev-ci-func-banner
    local topdir="${PWD#/}"
    local script="${CORESDIR}/autopsy.sh"
    local libdir="${CORESDIR}/lib/x86_64-linux-gnu"
    local kodir
    kodir="${topdir}/$(echo -n koreader-*/koreader)"
    run cd "${CORESDIR}"
    run mkdir -p "${CORESDIR}/${kodir%/*}"
    run mv "/${kodir}" "${CORESDIR}/${kodir}"
    run mkdir -p "${libdir}" "${CORESDIR}/usr"
    run ln -s ../lib "${CORESDIR}/usr"
    run cp -a /"${libdir#*/}"/{ld-*,libcrypto,libgcc_s,libssl,libstdc++}.so* "${libdir}"
    run cp -a /"${libdir#*/}"/{libc,libdl,libm,libnss_dns,libnss_files,libpthread,libresolv,librt,libthread_db}{-*,}.so* "${libdir}"
    # shellcheck disable=2016
    find "${libdir}" -type l -printf 'l="%p" t="%l"; ln -vsnf "${t##*/}" "$l"\n' | bash -x
    cat >"${script}" <<EOF
#!/bin/sh
kodir='${kodir}'
export DEBUGINFOD_URLS="https://debuginfod.ubuntu.com"
sosp="\$(find "\$kodir" -type f -name '*.so' -printf '%h\\n' | sort -u | xargs printf '%s:')"
exec gdb \
    -ex "set solib-absolute-prefix \$PWD" \\
    -ex "set solib-search-path \${sosp%:}" \\
    "\$kodir/luajit" \\
    corefile-luajit-*
EOF
    run chmod +x "${script}"
    run tar --zstd -cvf "coredumps.tar.zst" "${CORESDIR}"
    setenv UPLOAD_COREDUMPS=1
}

function kodev-ci-coredumps-handle() {
    kodev-ci-func-banner
    [[ -d "${CORESDIR}" ]] || return
    [[ "$(find "${CORESDIR}" -maxdepth 0 -empty)" ]] && return
    err 'we have coredumps!'
    ls -lh "${CORESDIR}"
    case "${RUNNER_OS}" in
        'Linux')
            kodev-ci-coredumps-handle-linux
            ;;
    esac
}

function kodev-ci-test() {
    kodev-ci-func-banner
    case "${RUNNER_OS}" in
        'Linux')
            setenv CORESDIR="${PWD}/coredumps"
            echo "${CORESDIR}/corefile-%e-%p-%t" | sudo tee /proc/sys/kernel/core_pattern
            mkdir -p "${CORESDIR}"
            ;;
    esac
    ulimit -c unlimited
    trap kodev-ci-coredumps-handle EXIT
    kodev-test ${JOB_RUNNER_DEBUG:+--verbose} --no-debug --no-build "$@"
}

function kodev-ci-release() {
    kodev-ci-func-banner
    kodev-release ${JOB_RUNNER_DEBUG:+--verbose} --no-debug --no-build "${JOB_UPDATE_TARGET}"
}

function kodev-ci-sign-apk() {
    kodev-ci-func-banner
    local uber_ver="$1"
    local uber_jar="uber-apk-signer-${uber_ver}.jar"
    shift
    download "https://github.com/patrickfav/uber-apk-signer/releases/download/v${uber_ver}/${uber_jar}"
    run java -jar "${uber_jar}" --apks "$@"
}

function kodev-ci-zsyncmake() {
    kodev-ci-func-banner
    [[ 2 -eq $# ]]
    local zsync_file="$1"
    local release_file="$2"
    shift
    run zsyncmake -C -o "${zsync_file}" -u "${release_file}" "${release_file}"
}

function kodev-ci-gh-release() {
    kodev-ci-func-banner
    local tag="$1"
    shift
    local new_commit old_commit
    run gh repo set-default "${GITHUB_REPOSITORY}"
    new_commit="$(git rev-parse HEAD)"
    info -cBROWN "new_commit: ${new_commit}"
    old_commit="$(gh release view "${tag}" --json targetCommitish | jq -r .targetCommitish || true)"
    info -cBROWN "old_commit: ${old_commit}"
    if [[ -n "${old_commit}" ]]; then
        old_commit="$(git rev-parse "${old_commit}")"
        info -cBROWN "old_commit: ${old_commit}"
    fi
    local create_release=0
    if [[ -z "${old_commit}" ]]; then
        create_release=1
    elif [[ "${old_commit}" != "${new_commit}" ]]; then
        run gh release delete --cleanup-tag --yes "${tag}"
        create_release=1
    fi
    if [[ "${create_release}" -ne 0 ]]; then
        run git tag --force "${tag}"
        run git push -f "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}" "refs/tags/${tag}"
        run gh release create --notes='.' --prerelease --target="${new_commit}" --title="${tag}" "${tag}"
    fi
    run gh release upload "${tag}" "$@"
}

function kodev-ci-shell() {
    if [[ -r ./job.sh ]]; then
        # shellcheck disable=SC1091
        . ./job.sh
    fi
    "$@"
}

function kodev-ci() {
    local fn="kodev-ci-$1"
    [[ "$(type -t "${fn}")" = function ]] || die 1 "invalid ci command: $1"
    shift
    "${fn}" "$@"
}

HELP_MSG="
usage: $0 COMMAND <ARGS>

Supported commands:

    activate            Bootstrap shell environment for kodev
    build               Build KOReader
    clean               Clean KOReader build
    fetch-thirdparty    Fetch thirdparty dependencies for build
    log                 Tail log stream for a running KOReader app
    release             Build KOReader release package
    run                 Run KOReader
    test                Run busted tests
    check               Run luacheck static-analysis
    cov                 Run busted tests for coverage
    wbuilder            Run wbuilder.lua script (useful for building new UI widget)
    prompt              Run a LuaJIT shell within KOReader's environment
"
[ $# -lt 1 ] && {
    echo "Missing command."
    echo "${HELP_MSG}"
    exit 1
}

if [[ "$1" = 'ci' && "${CI}" = 'true' ]]; then
    exec 2>&1 # avoid jumbled output…
    opt_timings=1
    shift 1
    kodev-ci "$@"
    exit
fi

case "${1}" in
    activate)
        echo "adding ${CURDIR} to \$PATH..."
        export PATH="${PATH}:${CURDIR}"
        eval "$(luarocks --lua-version 5.1 path --bin)"
        exec "${SHELL}"
        ;;
    fetch-thirdparty)
        kodev-fetch-thirdparty
        ;;
    clean)
        shift 1
        kodev-clean "$@"
        ;;
    build)
        shift 1
        kodev-build "$@"
        ;;
    release)
        shift 1
        kodev-release "$@"
        ;;
    wbuilder)
        shift 1
        kodev-wbuilder "$@"
        ;;
    run)
        shift 1
        kodev-run "$@"
        ;;
    test)
        shift 1
        kodev-test "$@"
        ;;
    check)
        shift 1
        kodev-check "$@"
        ;;
    cov)
        shift 1
        kodev-cov "$@"
        ;;
    prompt)
        kodev-build
        pushd "${EMU_DIR}" && {
            ./luajit -i setupkoenv.lua
        } && popd || exit
        ;;
    log)
        shift 1
        kodev-log "$@"
        ;;
    -h | --help)
        echo "${HELP_MSG}"
        exit 0
        ;;
    *)
        echo "Unknown command: $1."
        echo "${HELP_MSG}"
        exit 8
        ;;
esac

# vim: shiftwidth=4 softtabstop=4
